# 实验名称：直接插入排序，快速排序，直接选择排序验证
## 一、问题描述
进行以下三种排序方式的验证性实验
·直接插入排序
·快速排序
·直接选择排序

## 二、数据结构设计
采用数组的形式进行数据元素的存储
```c++
#define N 20
int a[N];
```

三、算法设计
1.随机生成数组
```c++
void rand_arr() {
	for (int i = 0; i < 20; i++) {
		a[i] = rand() % 100;
	}
}
```

2.插入排序
插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，如此重复，直至完成序列排序。
<1>从序列第一个元素开始，该元素可以认为已经被排序
<2>取出下一个元素，设为待插入元素，在已经排序的元素序列中从后向前扫描，如果该元素(已排序)大于待插入元素，将该元素移到下一位置。
<3>重复步骤2，直到找到已排序的元素小于或者等于待排序元素的位置，插入元素
<4>重复2，3步骤，完成排序。
```c++
void insert_sort(int* a, int len) {
	int key, j;
	for (int i = 1; i < len; i++) {
		key = a[i];
		j = i - 1;
		while (a[j] > key && j >= 0) {//找到插入位置
			a[j + 1] = a[j];//依次后移
			j--;
		}
		a[j + 1] = key;
	}
}
```

3.快速排序
<1>从数列中挑出一个元素，称为基准
<2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区退出之后，该基准就处于数列的中间位置
<3>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序
```c++
void quick_sort(int* a, int left, int right) {
	if (left > right)return;//结束条件
	int i = left, j = right, temp = a[left];//右哨兵和左哨兵
	while (i < j) {
		while (a[j] >= temp && i < j)//右哨兵从右向左找到第一个比基准大的
			j--;
		while (a[i] <= temp && i < j)//左哨兵从左向右找到第一个比基准小的
			i++;
		if (i < j) {//交换
			int t = a[i];
			a[i] = a[j];
			a[j] = t;
		}
	}
	a[left] = a[i];//交换基准与中心
	a[i] = temp;
	quick_sort(a, left, i - 1);//递归在左右半区继续排序
	quick_sort(a, i + 1, right);
}
```

4.选择排序
<1>找到数组中最小的元素，将它和数组的第一个元素交换位置。
<2>第二步，在剩下的元素中继续寻找最小的元素（即总的第二小的元素），和数组的第二个元素交换位置。
<3>如此循环，直到整个数组排序完成
```c++
void select_sort(int* a, int len) {
	int minn;
	for (int i = 0; i < len - 1; i++) {
		minn = i;
		for (int j = i + 1; j < len; j++) {
			if (a[j] < a[minn])//找到最小值
				minn = j;
		}
		//交换
		int temp = a[i];
		a[i] = a[minn];
		a[minn] = temp;
	}
}
```

## 四、界面设计
·随机生成元素序列并显示
·根据输入选择三种排序方式并输出相应的结果

图1 —— 界面设计

## 五、运行测试与分析
样本数为N = 20：

1.插入排序：

图2




2.快速排序：

图3
3.选择排序：

图4

## 六、实验收获与思考
本次实验我选择了对三种排序方法的验证性实验，虽然是最简单的实验，但通过对三种排序方法的验证，我收获了许多知识和对问题的思考，通过本次实验，我更加深入的了解了三种排序方式的原理和具体实现的方法，给我很深的启发和思考。






